---
layout: post
title: The Game Is Over!
date: '2007-03-26T10:57:00.001+02:00'
author: Joanna Rutkowska
tags: 
modified_time: '2009-03-25T16:06:59.977+01:00'
thumbnail: http://4.bp.blogspot.com/_Ti3q3Hdvels/Rgfep4q7IGI/AAAAAAAAABQ/B0UGxc6ITz4/s72-c/gameover.png
blogger_id: tag:blogger.com,1999:blog-24586388.post-6658513522828638474
blogger_orig_url: http://theinvisiblethings.blogspot.com/2007/03/game-is-over.html
---

People often say that once an attacker gets access to the kernel the game is over! That’s true indeed these days, and most of the research I have done over the past two years or so, was about proofing just that. Some people, however, go a bit further and say, that thus there is no point in researching ways to detect system compromises and, once an attacker got in, you should simply assume everything has been compromised and replace all the components, i.e. buy new machine (as the attacker might have <a href="http://www.blackhat.com/html/bh-federal-06/bh-fed-06-speakers.html#Heasman">modified the BIOS</a> or re-flashed <a href="http://www.blackhat.com/html/bh-dc-07/bh-dc-07-speakers.html#Heasman">PCI EEPROMs</a>), reinstall OS, all applications, etc.<br /><br /><img style="margin: 0px auto 10px; display: block; text-align: center;" src="http://4.bp.blogspot.com/_Ti3q3Hdvels/Rgfep4q7IGI/AAAAAAAAABQ/B0UGxc6ITz4/s400/gameover.png" alt="" id="BLOGGER_PHOTO_ID_5046246718660354146" border="0" /><br /><br />However, they miss one little detail – how can they actually know that the attacker got access to the system and that the game is over indeed and we need to reinstall just now?<br /><br />Well, we simply assume that the attacker <span style="font-weight: bold;">had to</span> make some mistake and that we, sooner or later, will find out. But what if she didn’t make a mistake?<br /><br />There are several trends of how this problem should be addressed in a more general and elegant way though. Most of them are based on a proactive approach. Let’s have a quick look at them…<br /><ol><li>One generic solution is to build in a prevention technology into the OS. That includes all the anti-exploitation mechanisms, like e.g. ASLR, Non Executable memory, Stack Guard/GS, and others, as well as some little design changes into OS, like e.g. implementation of least-privilege principle (think e.g. UAC in Vista) and some sort of kernel protection (e.g. securelevel in BSD, grsecurity on Linux, signed drivers in Vista, etc).<br /><br />This has been undoubtedly the most popular approach for the last couple of years and recently it gets even more popular, as Microsoft implemented most of those techniques in Vista.<br /><br />However, everybody who follows the security research for at least several years should know that all those clever mechanisms have all been bypassed at least once in their history. That includes attacks against Stack Guard protection presented back in 2000 by <a href="http://phrack.org/archives/56/p56-0x05">Bulba and Kil3r</a>, several ways to bypass PaX ASLR, like those described by <a href="http://phrack.org/archives/58/p58-0x04">Nergal in 2001</a> and <a href="http://phrack.org/archives/59/p59-0x09.txt">by others several months later</a> as well as exploiting <a href="http://lists.immunitysec.com/pipermail/dailydave/2005-March/001619.html">the privilege elevation bug in PaX</a> discovered by its author in 2005. Also the Microsoft's Hardware DEP (AKA NX) has been demonstrated <a href="http://uninformed.org/?v=2&a=4&amp;t=sumry">to be bypassable</a> by skape and Skywing in 2005.<br /><br />Similarly, kernel protection mechanisms have also been bypassed over the past years, starting e.g. with <a href="http://archives.neohapsis.com/archives/bugtraq/2002-05/0145.html">this nice attack against grsecurity /dev/(k)mem protection</a> presented by Guillaume Pelat in 2002. In 2006 Loic Duflot demonstrated that BSD's famous <a href="http://www.ssi.gouv.fr/fr/sciences/fichiers/lti/cansecwest2006-duflot-paper.pdf">securelevel mechanism can also be bypassed</a>. And, also last year, I showed that <a href="http://www.blackhat.com/html/bh-usa-06/bh-usa-06-speakers.html#Rutkowska">Vista x64 kernel protection is not foolproof either</a>.<br /><br />The point is – all those hardening techniques are designed to make exploitation <span style="font-style: italic;">harder</span> or to <span style="font-style: italic;">limit </span>the damage after a successful exploitation, but not to be 100% foolproof. On the other hand, it must be said, that they probably represent the best prevention solutions available for us these days.</li><br /><li>Another approach is to dramatically redesign the whole OS in such a way that all components (like e.g. drivers and serves) are compartmentalized, e.g. run as separate processes in usermode, and consequently are isolated not only from each other but also from the OS kernel (micro kernel). The idea here is that the most critical components, i.e. the micro kernel, is very small and can be easily verified. Example of such OS is <a href="http://www.minix3.org/">Minix3</a> which is still under development though.<br /><br />Undoubtedly this is a very good approach to minimize impact from system or driver faults, but does not protect us against malicious system compromises. After all if an attacker exploits a bug in a web browser, she may only be interested in modifying the browser’s code. Sure, she probably would not be able to get access to the micro kernel, but why would she really need it?<br /><br /><span style="font-size:85%;">Imagine, for example, the following common scenario: many online banking systems require users to use smart cards to sign all transaction requests (e.g. money transfers). This usually works by having a browser (more specifically an ActiveX control or Firefox’s plugin) to display a message to a user that he or she is about to make e.g. a wire transfer to a given account number for a given amount of money. If the user confirms that action, they should press an ‘Accept’ button, which instructs browser to send the message to the smart card for signing. The message itself is usually just some kind of formatted text message specifying the source and destination account numbers, amount of money, date and time stamp etc. Then the user is asked to insert the smart card, which contains his or her private key (issued by the bank) and to also enter the PIN code. The latter can be done either by using the same browser applet or, in slightly more secure implementations, by the smart card reader itself, if it has a pad for entering PINs.<br /><br />Obviously the point here is that malware should not be able to forge the digital signature and only the legitimate user has access to the smart card and also knows the card’s PIN, so nobody else will be able to sign that message with the user’s key.<br /><br />However, it’s just enough for the attacker to replace the message while it’s being send to the card, while displaying the original message in the browser’s window. This all can be done by just modifying (“hooking”) the browser’s in-memory code and/or data. No need for kernel malware, yet the system (the browser more specifically) is compromised!</span><br /><br />Still, one good thing about such a system design is that if we don’t allow an attacker to compromise the microkernel, then, at least in theory, we can write a detector capable of finding that some (malicious) changes to the browsers memory have been introduced indeed. However, in practice, we would have to know how exactly the browser’s memory should look like, e.g. which function pointers in Firefox’s code should be verified in order to find out whether such a compromise has indeed occurred. Unfortunately we can not do that today.</li><br /><li>Alternative approach to the above two, which does not require any dramatic changes into OS, is to make use of so called <span style="font-style: italic;">sound </span>static code analyzers to verify all sensitive code in OS and applications. The <span style="font-style: italic;">soundness </span>property assures that the analyzer has been mathematically proven not to miss even a single potential run time error, which includes e.g. unintentional execution flow modifications. The catch here is that soundness doesn’t mean that the analyzer doesn’t generate false positives. It’s actually mathematically proven that we can’t have such an ideal tool (i.e. with zero false positive rate), as the problem of analyzing all possible program execution paths is incomputable. Thus, the practical analyzers always consider some superset of all possible execution flows, which is easy to compute, yet may introduce some false alarms and the whole trick is how to choose that superset so that the number of false positives is minimal.<br /><br /><a href="http://www.astree.ens.fr/">ASTREE</a> is an example of a sound static code analyzer for the C language (although it doesn’t support programs which make use of dynamic memory allocation) and it apparently has been used to verify the primary flight control software for Airbus A340 and A380. Unfortunately, there doesn’t seem to be any publicly available sound binary code static analyzers… (if anybody knows any links, you’re more then welcome to paste the links under this post – just please make sure you’re referring to sound analyzers).<br /><br />If we had such sound and precise (i.e. with minimal rate of false alarms) binary static code analyzer that could be a big breakthrough in the OS and application security.<br /><br />We could imagine, for example, a special authority for signing device drivers for various OSes and that they would first perform such a formal static validation on submitted drivers and, once passed the test, the drivers would be digitally signed. Plus, the OS kernel itself would be validated itself by the vendor and would accept only those drivers which were signed by the driver verification authority. The authority could be an OS vendor itself or a separate 3rd party organization. Additionally we could also require that the code of all security critical applications, like e.g. web browser be also signed by such an authority and set a special policy in our OS to allow e.g. only signed applications to access network.<br /><br />The only one week point here is, that if the private key used by the certification authority gets compromised, then the game is over and nobody really knows that… For this reason it would be good, to have more then one certification authority and require that each driver/application be signed by at least two independent authorities.</li></ol><br />From the above three approaches only the last one can guarantee that our system will not get compromised ever. The only problem here is that… there are no tools today for static binary code analysis that would be proved to be sound and also precise enough to be used in practice…<br /><br />So, today, as far as proactive solutions are considered, we’re left only with solutions #1 and #2, which, as discussed above, can not protect OS and applications from compromises in 100%. And, to make it worse, do not offer any clue, whether the compromise actually occurred.<br /><br />That’s why I’m trying so much to promote the idea of <a href="http://theinvisiblethings.blogspot.com/2007/01/towards-verifiable-operating-systems.html">Verifiable Operating Systems</a>, which should allow to at least find out (in a systematic way) whether the system in question has been compromised or not (but, unfortunately not to find whether the single-shot incident occurred). The point is that the number of required design changes should be fairly small. There are some problems with it too, like e.g. verifying JIT-like code, but hopefully they can be solved in the near feature. Expect me to write more on this topic in the near feature.<br /><br />Special thanks to Halvar Flake for eye-opening discussions about sound code analyzers and OS security in general.