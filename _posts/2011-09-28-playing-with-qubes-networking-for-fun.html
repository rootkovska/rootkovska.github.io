---
layout: post
title: Playing with Qubes Networking for Fun and Profit
date: '2011-09-28T16:36:00.002+02:00'
author: Joanna Rutkowska
tags:
- qubes
modified_time: '2013-02-21T15:48:49.775+01:00'
thumbnail: http://3.bp.blogspot.com/-HGvCszJ422w/ToMeJm16CMI/AAAAAAAAAJA/CdX1Y-Ct_uc/s72-c/qubes-default-net-config.png
blogger_id: tag:blogger.com,1999:blog-24586388.post-2682693250711953422
blogger_orig_url: http://theinvisiblethings.blogspot.com/2011/09/playing-with-qubes-networking-for-fun.html
---

Today, I would like to showcase some of the cool things that one can do with the Qubes networking infrastructure, specifically with all the new features that have been brought by the just released Qubes Beta 2. This will cover the use of multiple Net VMs for creating isolated networks,  the use of a Proxy VM for creating a transparent Tor Proxy VM, as well as demonstration of how to use a Standalone VM with manually assigned devices, to create a “WiFi pen-testing” VM, which surely represents the “for fun” aspect of this post.<br /><br /><style type="text/css">p { margin-bottom: 0. </style><b>Qubes Networking Intro</b><br /><br />From the networking point of view there are three types of VMs in Qubes:<br /><style type="text/css">p { margin-bottom: 0.08in; } </style>          <style type="text/css">p { margin-bottom: 0.08in; } </style>  <br /><ul><li><div style="margin-bottom: 0in;">Net VMs, that have networking  devices assigned to them, such as e.g. a WiFi or Ethernet card. Each  Net VM contains a Xen network backend that is used to provide  networking to all VMs that are connected to this Net VM.</div></li><li><div style="margin-bottom: 0in;">Regular VMs (AppVMs) that use the  networking provided by Net VMs (so they have Xen network frontends  that provide virtual interfaces that are backed by the backend in  the corresponding Net VM.</div></li><li><div style="margin-bottom: 0in;">Proxy VMs that combine both of the  above: to Net VMs they look like regular AppVMs, because they are  consumers of the networking they provide, but to other AppVMs they  act as if they were Net VMs themselves, allowing other VMs to  connect to them. Of course the Proxy VMs do not have directly  assigned networking devices – they use the networking provided by  the Net VM that they connect to. One can chain many Proxy VMs, as we  will see below.</div></li></ul><style type="text/css">p { margin-bottom: 0.08in; } </style>          <style type="text/css">p { margin-bottom: 0.08in; } </style>  <br /><div style="margin-bottom: 0in;"><span style="font-style: normal;">The virtual interfaces in client VMs are called </span><span style="font-family: Liberation Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">ethX</span></span></span></span><span style="font-style: normal;">, and are provided by the </span>xen_netfront<span style="font-style: normal;"> kernel module, and the corresponding interfaces in the Net/Proxy VM are called </span><span style="font-family: Liberation Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">vifX.Y</span></span></span></span> and are created by the xen_netback module.</div><br />Each Net and Proxy VM implements NAT, specifically masquerading, for all the connected VMs. Additionally to this SNAT, each Net or Proxy VM provides also DNAT redirection for DNS resolutions, so that each VM behind a Proxy or Net VM thinks that it uses a DNS in the Net/Proxy VM, but in fact all the DNS request are DNAT-ed by all the Proxy and Net VMs down the original DNS that is provided to the final Net VM. This smart trick allows us to avoid running a DNS caching server in Proxy/Net VMs. <br /><div style="margin-bottom: 0in;"><br />Also, any VM-to-VM traffic, among the VMs connected to the same Net/Proxy VM is blocked by default.</div><div style="margin-bottom: 0in;"><br />Additionally, each Proxy VM enforces system-wide firewaling rules, specifically the rules for all the directly connected VMs. Those firewalling rules are centrally managed in Dom0 and exposed to each Proxy VM through Xen store. One useful application of this firewalling mechanism is to limit certain VMs to only specific type of white-listed traffic to minimize likelihood of user mistakes. A good example could be a work VM that might be limited to network connectivity only with the select corporate servers and denied all other traffic. This way, when the user receives an email message with an embedded http link (possibly leading to a malicious website) and accidentally clicks on it, nothing wrong happens.</div><div style="margin-bottom: 0in;"><br />The current infrastructure doesn't support IPv6 routing, but we will likely add this support in the upcoming Beta 3.</div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;"><style type="text/css">p { margin-bottom: 0.08in; } </style>  </div><div style="font-style: normal; margin-bottom: 0in;"><b>The default networking topology in Qubes OS</b><br /><br />When you proceed with the default installation of Qubes Beta 2, then your initial networking topology looks like on the diagram below:</div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-HGvCszJ422w/ToMeJm16CMI/AAAAAAAAAJA/CdX1Y-Ct_uc/s1600/qubes-default-net-config.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="272" src="http://3.bp.blogspot.com/-HGvCszJ422w/ToMeJm16CMI/AAAAAAAAAJA/CdX1Y-Ct_uc/s400/qubes-default-net-config.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">The default network configuration in Qubes.</td></tr></tbody></table><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><style type="text/css">p { margin-bottom: 0.08in; } </style> So, by default there is one Net VM, called 'netvm', that is automatically assigned all the networking devices in the system. There is also one Proxy VM, called 'firewallvm' that is directly connected to the default Net VM, and which provides networking to all other VMs in the system. This  Proxy VM is used for firewall rules enforcement. Each such service VM consumes 200MB of RAM by default.</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><style type="text/css">p { margin-bottom: 0.08in; } </style>  </div><div style="font-style: normal; margin-bottom: 0in;"><b>Network-isolated VMs</b></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><style type="text/css">p { margin-bottom: 0.08in; } </style>  </div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br />For some VMs it might be desirable to completely disconnect them from any kind of networking access. This can be easy done using the following command (issued from Dom0's konsole):</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;">[dom0]$ qvm-prefs -s </span><i><appvm name=""></appvm></i><span style="font-style: normal;"> netvm none</span></span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br />For example I have a 'vault' VM that I use for keeping my master PGP keys, and other secrets, and this machine is not connected to any network.</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><style type="text/css">p { margin-bottom: 0.08in; } </style>  </div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><style type="text/css">p { margin-bottom: 0.08in; } </style>  </div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><b>Using multiple Net VMs for physically isolated networks</b>&nbsp;</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">In some scenarios the machine might be connected to two or more physically separate networks (e.g. safe corporate intranet, reachable via ethernet cable on the user's desk, and the unsafe and evil Internet, reachable via WiFi card).</div><div style="font-style: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; margin-bottom: 0in;">It is easy to use more than one Net VMs in Qubes, and assign different networking devices to different Net VMs, and also decide which VMs are connected to which Net VMs. The diagram below presents an exemplary such setup:</div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-_04df-F5fW0/ToMe2QX_K8I/AAAAAAAAAJE/azWeNG5R5qc/s1600/qubes-multi-netvm-config.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="348" src="http://3.bp.blogspot.com/-_04df-F5fW0/ToMe2QX_K8I/AAAAAAAAAJE/azWeNG5R5qc/s400/qubes-multi-netvm-config.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">A simple setup with two isolated networks, and one fully isolated domain ('vault').</td></tr></tbody></table><div style="font-style: normal; margin-bottom: 0in;">&nbsp;          <style type="text/css">p { margin-bottom: 0.08in; } </style>  </div><div style="font-style: normal; margin-bottom: 0in;">We could created such a setup using the following commands (issued in Dom0):</div><div style="font-style: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-create netvm1 --net --label red</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-create netvm2 --net --label yellow</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">Currently <span style="font-family: Liberation Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">qvm-create</span></span></span></span> when used with the <span style="font-family: Liberation Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">--net</span></span></span></span> option automatically assigns all networking devices to the just created VM, so in the example above you would want to remove extra devices from each Net VM using <style type="text/css">p { margin-bottom: 0.08 </style><span style="font-family: Liberation Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">qvm-pci -d</span></span></span></span>, leaving only those you really want, e.g.:<span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">&nbsp;</span></span><br /><br /><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-pci -l netvm1 <span style="font-family: DejaVu Serif,serif;"># to get a list of currently assigned devices</span></span></span></div><style type="text/css">p { margin-bottom: 0.08in; } </style>          <style type="text/css">p { margin-bottom: 0.08in; } </style>  <br /><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-pci -d netvm1 02:00.0</span></span></div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">Now we should create the Firewall VMs:</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-create firewallvm1 --proxy --label green</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-create firewallvm2 --proxy --label green</span></span></div><div style="margin-bottom: 0in;"><br />... and connect them to proper Net VMs:</div><div style="margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-prefs -s firewallvm1 netvm netvm1</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-prefs -s firewallvm2 netvm netvm2</span></span></div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">And now, for any other VM, just set the appropriate Net VM (either firewallvm1 or firewallvm2, or 'none), to get it assigned to either of the isolated networks, e.g.:</div><div style="margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-prefs -s banking netvm firewallvm1</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-prefs -s xfiles netvm firewallvm2</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-prefs -s vault netvm none</span></span></div><div style="margin-bottom: 0in;">...</div><div style="font-style: normal; margin-bottom: 0in;"><style type="text/css">p { margin-bottom: 0.08in; } </style>  </div><div style="font-style: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; margin-bottom: 0in;">This configuration provides very strong isolation between the VMs belonging to network #1, and the VMs belonging to network #2. Specifically, this becomes significant if we fear about potential remotely exploitable bugs in the client code of the core TCP/IP stack (in this case the Net VM could potentially compromise all the connected VMs -- but the same problem applies to even physically separated machines that use the same network).</div><div style="font-style: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; margin-bottom: 0in;"><style type="text/css">p { margin-bottom: 0.08in; } </style>  </div><div style="font-style: normal; margin-bottom: 0in;"><b>Setting up Tor Proxy using a Proxy VM</b></div><div style="font-style: normal; margin-bottom: 0in;"><br />Let's now play a bit with Proxy VMs and see how we can use it to create a simple Tor proxy VM. Such a VM would provide anonymized networking to all its clients, so would allow to easily create VMs for anonymous Internet access. The simple setup we would like to prepare is depicted on the figure below:<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-eG2Y4_xJxD0/ToMgWVNiEjI/AAAAAAAAAJI/pWNCiXq-qKs/s1600/qubes-torproxy-config.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="225" src="http://1.bp.blogspot.com/-eG2Y4_xJxD0/ToMgWVNiEjI/AAAAAAAAAJI/pWNCiXq-qKs/s400/qubes-torproxy-config.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">The 'torvm' Proxy VM provides anonymized networking to 'anon-web' and 'anon-bitcoin' VMs. All the traffic generated by the VMs behind 'torvm' is either fed into the Tor network, or discarded. Furthermore, any app running in those VMs is not able to read any global system identifiers, such as the external IP, external MAC address, etc.</td></tr></tbody></table><style type="text/css">p { margin-bottom: 0.08in; } </style> <br /><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">Our Tor proxy would forward only the Tor traffic, so we don't have to fear about some Tor-not-aware applications, or even intentionally malicious ones to compromise the privacy of our connection. This is because such applications have no way to generate traffic to the outside world without going through our Tor proxy (unless they could exploit a hypothetical vulnerability in the Tor process running in the Tor VM). Also, the applications running in any VM behind the Tor proxy are not able to determine any globally identifiable IDs, such as the user's external IP address, the real MAC address used by real NICs, etc.</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">Interestingly just after writing the above paragraph, I discovered that one of our xenstore keys had wrong permissions and, as a result, any VM could read it and get to know the actual external IP (the key is used by a Net VM to communicate the external IP configuration to the connected Proxy VMs, so they could know when to update the firewall configuration). The fix for this problem is <a href="http://git.qubes-os.org/?p=mainstream/core.git;a=commitdiff;h=59f71f634af596c8fe2ef507509bf1ae850286c7">here</a>, and the update (qubes-core-dom0-1.6.32) is now available for Dom0 (just do <a href="http://wiki.qubes-os.org/trac/wiki/SoftwareUpdateDom0">qvm-dom0-update</a>to get it installed).</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">&nbsp;          <style type="text/css">p { margin-bottom: 0.08in; } </style> </div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">So, this represents a rather strong setup for use with Tor. Let's now have a look at how to practically  create such a configuration, step by step.</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">First, let's create the VM that will become our Tor proxy:</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-create torvm --proxy --label green</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">This will create a Proxy VM named 'torvm', based on the default template. We will need to now start the template VM and install the Tor client there:</div><div style="font-style: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-run -a fedora-14-x64 gnome-terminal</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">Alternatively, if we didn't trust the Tor client rpm package to be non-malicious, specifically for its installation scripts to be non malicious, we could have based this on a different template, e.g. one used for less trusted VMs, or we could installed the Tor client in <span style="font-family: Liberation Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">/usr/local</span></span></span></span>, that is backed by the VM's private storage, but this would require compiling Tor from sources.</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">Now, in the just started template VM, lets install the Tor client and (optionally) the Vidalia graphical frontend:</div><div style="margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[fedora-14-x64]$ sudo yum install tor vidalia</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;">And then power off the template VM. Now, every VM based on this template, started after the template shutdown, will also see the Tor binary in its filesystem.</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;">Let's now configure our torvm to properly start Tor proxying at boot:</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-run -a torvm gnome-terminal</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;">Now, we will create the following script for starting up the Tor transparent proxy and setting up traffic redirection using iptables:</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[torvm]$ vim /rw/config/start_tor_proxy.sh</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;"><span style="font-size: small;"><span style="font-family: Liberation Serif,serif;">...</span></span>and now paste the following into this file:</span></span></div><blockquote><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">#!/bin/sh</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">killall tor</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">QUBES_IP=$(xenstore-read qubes_ip)</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">TOR_TRANS_PORT=9040</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">if [ X$QUBES_IP == X ]; then</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">echo "Error getting QUBES IP!"</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">echo "Not starting Tor, but setting the traffic redirection anyway to prevent leaks."</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">QUBES_IP="127.0.0.1"</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">else</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">/usr/bin/tor \</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">--SocksPort 0 \</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">--TransListenAddress $QUBES_IP --TransPort $TOR_TRANS_PORT \</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">--DNSListenAddress $QUBES_IP --DNSPort 53 \</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">--RunAsDaemon 1 --ControlPort 9051 \</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">|| echo "Error starting Tor!"</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">fi</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">echo “0” &gt; /proc/sys/net/ipv4/ip_forward </span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">/sbin/iptables -t nat -F</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">/sbin/iptables -t nat -A PREROUTING -i vif+ -p udp --dport 53 -j DNAT --to-destination $QUBES_IP:53</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">/sbin/iptables -t nat -A PREROUTING -i vif+ -p tcp -j DNAT --to-destination $QUBES_IP:$TOR_TRANS_PORT</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">/sbin/iptables -I INPUT 1 -i vif+ -p udp --dport 53 -j ACCEPT</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">/sbin/iptables -I INPUT 2 -i vif+ -p tcp --dport 9040 -j ACCEPT</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">/sbin/iptables -F FORWARD</span></span></div></blockquote><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"></div><br /><blockquote><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">echo “1” &gt; /proc/sys/net/ipv4/ip_forward </span></span></blockquote><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;">Except for the “<span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">QUBES_IP=$(xenstore-read qubes_ip)</span></span></span>” line that reads the torvm's IP address, there is nothing Qubes-specific in the above listing. It's just a standard way of setting up transparent Tor proxy.</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><br /></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;">It is important that this file be located in the <span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">/rw</span></span></span>directory, as this directory is backed by the VM's private storage and will survive VM reboots. The VM's root file-system is read-only and all the changes to it are lost on VM shutdown (VM gets an illusion of the root fs being writeable thanks to Copy-On-Write mechanism, but the actual COW backing device is cleared upon each VM shutdown).</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><br /></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;">We should also modify the<span style="font-family: inherit;"> <span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">/rw/config/rc.local</span></span></span></span>script, to ensure that our Tor proxy is automatically started -- just paste the following into this script:</span></span></div><blockquote><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">#!/bin/sh</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;"># Uncomment this if you would like to use a custom torrc file:</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">#rm -f /rw/config/log</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">#ln -sf /rw/config/torrc /etc/tor/torrc</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">chkconfig qubes_netwatcher off</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">chkconfig qubes_firewall off</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">/rw/config/start_tor_proxy.sh</span></span></div></blockquote><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;">Finally we should also provide a script that would restart our proxy in case the user dynamically switched the NetVM, which would result in the completely different routing. This could be done by creating a script with predefined name <span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">qubes_ip_change_hook</span></span></span>within <span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">/rw/config/</span></span></span>directory:</span></span></div><blockquote><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">#!/bin/sh</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">/rw/config/start_tor_proxy.sh</span></span></div></blockquote><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;">Make sure that all the scripts are executable (chmod +x). And that's all. Now, shutdown the torvm:</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-run --shutdown --wait torvm</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;">From now on, every time you start the torvm (or when Qubes starts it in response to start of some other VM that uses torvm as its Net VM), the Tor transparent proxy should be automatically started.</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><br /></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;">Let's test this by creating a VM that would be using the just created Tor proxy:</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-create anon-web --label black</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-prefs -s  anon-web netvm torvm</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;">Now, every time you start the anon-web VM (e.g. by clicking on the Web browser icon in the anon-web's start menu), Qubes will also ensure that torvm is up and running, and this in turn would configure all the Tor proxying for this VM.</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><br /></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;">Fo additional control one might want to use Vidalia, the graphical front end for Tor (this should be installed within the template VM that has been used for torvm). We could easily start Vidalia by just typing:</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-run -a torvm vidalia</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;"><span style="font-size: small;">We should however make sure to disable "Start the Tor software when vidalia starts" option in Settings/General in Vidalia. Otherwise, Vidalia might kill your original Tor (that has transparent proxy open) and start own without transparent proxy enabled.</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-DUPCtbu3svY/ToQpDggfR0I/AAAAAAAAAJc/xRTJYPZusqI/s1600/tor.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="225" src="http://1.bp.blogspot.com/-DUPCtbu3svY/ToQpDggfR0I/AAAAAAAAAJc/xRTJYPZusqI/s400/tor.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">The web browser runs in the 'anon-web' VM that uses 'torvm' for networking access, and thus all the traffic generated by 'anon-web' is routed through the Tor network, or discarded if it's a different traffic than TCP or DNS.</td></tr></tbody></table><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><br /><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><style type="text/css">p { margin-bottom: 0.08in; } </style> </div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: inherit;">Of course one case easily create more VMs that would be using torvm as their Net VM, as so would have anonymized network access. The beauty of this solution is that in case one of my anonymized VM gets compromised, others do not. Plus, the already mentioned benefit, that no matter whether apps in those VMs are buggy, or even intentionally malicious, they would not be able to leak out the user's external IP address.</span></div><div style="font-style: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; margin-bottom: 0in;"><b>Creating a WiFi pen-testing VM</b></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">Finally let's have some fun and create a WiFi pen-testing VM. The desired config is depicted below:</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-6tMmKe1J2T0/ToQpS-gKzGI/AAAAAAAAAJg/gnrYrarQuMI/s1600/qubes-wififun.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="239" src="http://3.bp.blogspot.com/-6tMmKe1J2T0/ToQpS-gKzGI/AAAAAAAAAJg/gnrYrarQuMI/s320/qubes-wififun.png" width="320" /></a></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><style type="text/css">p { margin-bottom: 0.08in; } </style> </div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">Because we would like to use all sorts of <strike>l33t h4x0r t00lz</strike><span style="text-decoration: none;">pen-testing security software in this VM, it would make sense to create it as a </span><span style="text-decoration: none;"><i>Standalone VM</i></span><span style="text-decoration: none;">, which means that it would get its own copy of the whole file-system (as opposed to just the home directory, </span><span style="font-family: Liberation Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;"><span style="text-decoration: none;">/rw</span></span></span></span></span><span style="text-decoration: none;">and </span><span style="font-family: Liberation Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;"><span style="text-decoration: none;">/usr/local</span></span></span></span></span><span style="text-decoration: none;">, as it is the case with regular Qubes VMs). This would ease the installation of all the extra software we would need there, and also ensure that even if the install/build scripts were malicious, the damages would be contained only to this very VM and nothing else. Also, for some reason the standard Linux WiFi stack and drivers still don't support injection on (all?) most of the WiFi cards out of the box, so we would need to patch the actual kernel drivers -- yet another reason to use a Standalone VM in this case.</span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;">So, let's create the VM first, and assign a WiFi card to it:</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-create wififun --standalone --label yellow</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-prefs -s wififun memory 800 <span style="font-family: DejaVu Serif,serif;"># ensure at least this mem at startup</span></span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-prefs -s wififun kernel none <span style="font-family: DejaVu Serif,serif;"># use own copy of kernel and modules</span></span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-pci -a wififun <bdf adress="" device="" of="" wifi="" your=""></bdf></span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="margin-bottom: 0in;"><span style="text-decoration: none;">You can easily find the BDF address of any device using the </span><span style="font-family: Liberation Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;"><span style="text-decoration: none;">lspci</span></span></span></span></span><span style="text-decoration: none;">command in Dom0 -- this would be something like e.g. “02:00.0”. You should make sure that this WiFi card is not used by any other VM, specifically by your default Net VM (called 'netvm' in a standard Qubes installation). Ideally you could just use a dedicated Express Card-based WiFi card, leaving the built in WiFi assigned to your default Net VM.</span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="margin-bottom: 0in; text-decoration: none;">Because it's a Standalone VM, Qubes will make a copy of the whole root filesystem, and thus it would eat about 5GB of your disk (normal VMs would take only as much space as their private fs takes up).</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;">Let's now start the VM...</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-run -a wififun gnome-terminal</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;">... and then install the prerequisite software there, starting with downloading the reasonably new compat-wireless sources, together with the required injection patches, and then building and installing the new kernel modules. All actions below are now executed within the VM. This stuff here is really nothing Qubes- or Xen-specific -- one would do more or less the same on any Linux in order to get injection working (so, treat this as a free bonus WiFi hacking tutorial on Linux).</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]$ wget http://linuxwireless.org/download/compat-wireless-2.6/compat-wireless-2011-07-14.tar.bz2</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]$ wget http://patches.aircrack-ng.org/channel-negative-one-maxim.patch</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;"><span style="background: none repeat scroll 0% 0% transparent;">[wififun]$ wget http://patches.aircrack-ng.org/mac80211-2.6.29-fix-tx-ctl-no-ack-retry-count.patch</span></span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;"><span style="background: none repeat scroll 0% 0% transparent;">[wififun]$ wget http://patches.aircrack-ng.org/mac80211.compat08082009.wl_frag+ack_v1.patch</span></span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]$ sudo yum install kernel-devel patch gcc</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]$ tar xjf compat-wireless-2011-07-14.tar.bz2</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]$ cd compat-wireless-2011-07-14</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]$ patch -p1 &lt; ../channel-negative-one-maxim.patch</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;"><span style="background: none repeat scroll 0% 0% transparent;">[wififun]$ patch -p1 &lt; ../mac80211-2.6.29-fix-tx-ctl-no-ack-retry-count.patch</span></span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;"><span style="background: none repeat scroll 0% 0% transparent;">[wififun]$ patch -p1 &lt; ../mac80211.compat08082009.wl_frag+ack_v1.patch</span></span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]$ make</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]$ sudo make unload</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]$ sudo make install</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="margin-bottom: 0in;">Now, lets reboot the VM to ensure that all the patched drivers will get properly loaded on each VM boot:</div><div style="margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-run --shutdown --wait wififun</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[dom0]$ qvm-run -a wififun gnome-terminal</span></span></div><div style="font-style: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">Let's first see if the WiFi driver got properly loaded and if the interface has been created (look for <span style="font-family: Liberation Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">wlanX</span></span></span></span>interface):</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]$ ifconfig -a</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">If yes, then proceed with the steps below (if not, then have a look into dmesg and see what was the problem):</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]$ sudo bash</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]# yum install aircrack-ng dnsmasq</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]# airmon-ng start wlan0 <channel></channel></span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]# iptables -F INPUT</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]# iptables -F FORWARD</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]# echo “1” &gt; /proc/sys/net/ipv4/ip_forward</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="margin-bottom: 0in;">Note that you don't need to add any explicit masquerading rules, as they are applied by default on Qubes VMs (you can take a look at the <i>nat</i> table in the VM if you want to see by yourself).</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="margin-bottom: 0in;">Edit the <span style="font-family: Liberation Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">/etc/dnsmasq.conf</span></span></span></span>, so that it contains at least the following:</div><div style="margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">interface=at0</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">dhcp-range=192.168.0.50,192.168.0.150,12h</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">and then start the dnsmasq daemon -- we will use it for providing DHCP to our fake AP (the at0 interface will be created by airbase-ng and emulates the “uplink” of a traditional AP):</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]# /etc/init.d/dnsmasq start</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="margin-bottom: 0in;">And finally the fake AP:</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in; text-decoration: none;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]# airbase-ng -e free_wifi mon0</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">and on another console (before any client connects, but after <span style="font-family: Liberation Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">airbase-ng</span></span></span></span>got started), configure the <span style="font-family: Liberation Mono,monospace;"><span style="font-size: x-small;"><span style="font-style: normal;"><span style="font-weight: normal;">at0</span></span></span></span>interface (make sure it matches what you wrote into dnsmasq.conf):</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;"><span style="text-decoration: none;"><span style="font-style: normal;"><span style="font-weight: normal;">[wififun]# </span></span></span>ifconfig at0 192.168.0.1 up</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">(you can also add an udev rule to that automatically).</div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">and just to verify it really is working:</div><div style="margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;"><span style="text-decoration: none;"><span style="font-style: normal;"><span style="font-weight: normal;">[wififun]# </span></span></span>tcpdump -i at0</span></span></div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">... and now, just wait for a client to connect to your AP. What you do next is only limited by your imagination... But hey, this article is about Qubes networking and not about 0wning client systems ;)</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">Here's an innocent example using Moxie's sslstrip (amazing this attack still works so well at the end of 2011...):</div><div style="margin-bottom: 0in;"><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-3StOOvmJ1YI/ToQpdFycIAI/AAAAAAAAAJk/KnOvneQZDjU/s1600/wififun.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="225" src="http://1.bp.blogspot.com/-3StOOvmJ1YI/ToQpdFycIAI/AAAAAAAAAJk/KnOvneQZDjU/s400/wififun.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">My 'wififun' VM in action using a simple sslstrip attack, that surprisingly still works pretty nice...</td></tr></tbody></table><div style="margin-bottom: 0in;"><style type="text/css">p { margin-bottom: 0.08in; } </style> </div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">Please note that as your wififun VM is a regular Qubes VM, it is automatically connected to the default Net VM, which in turn provides networking to it. That's why it is so easy to create a fully functioning fake AP.</div><div style="font-style: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">When using custom driver domains, there are currently some catches you should be aware:</div><div style="font-style: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; margin-bottom: 0in;"><b>Catch #1: </b><span style="font-weight: normal;"><span style="background: none repeat scroll 0% 0% transparent;">When you start a driver domain </span></span><i><span style="font-weight: normal;"><span style="background: none repeat scroll 0% 0% transparent;">late</span></span></i><span style="font-weight: normal;"><span style="background: none repeat scroll 0% 0% transparent;">after system boot, so after some days of uptime and extensive use of VMs, Xen might not be able to allocate enough continues (in terms of MFNs) memory for a driver domain. And PV driver domains, unlike normal domains or HVM driver domains, do require MFN-continuous  memory for their DMA buffers (HVM domains do not need that, because IOMMU can create an illusion of this; even though IOMMU is also used for PV driver domains, for protection, it doesn't actively translate bus addresses into GMFNs).</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="background: none repeat scroll 0% 0% transparent;">This is usually not a big problem in practice, because in most cases all the driver domains are started early at system boot, when there is still plenty of non-fragmented memory available. However it might become a problem when one wishes to start e.g. the WiFi pen-testing at some later time. The work around is to close as many VMs as possible before starting such driver domain, and then also reducing, for a moment, the amount of memory assigned to Dom0:</span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;"><span style="background: none repeat scroll 0% 0% transparent;">[dom0]$ xm mem-set 0 1600m</span></span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-weight: normal; margin-bottom: 0in;"><span style="background: none repeat scroll 0% 0% transparent;">and then starting the driver domain should be fine. Now we can start all other domains, and that should no longer be problematic for the already running driver domain.</span></div><div style="font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; margin-bottom: 0in;"><b>Catch #2: </b><span style="font-weight: normal;">Some network cards, notably Express Cards, might not work well with the 3.0.4 pvops kernel that we use in all VMs by default. In that case you might want to try to use the 2.6.38.3 xenlinux kernel in your WiFi fun VM -- to do that, follow these steps:</span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;"><span style="background: none repeat scroll 0% 0% transparent;">[dom0]$ sudo qvm-dom0-update kernel-qubes-vm-2.6.38.3-10.xenlinux.qubes</span></span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;"><span style="font-weight: normal;"><span style="background: none repeat scroll 0% 0% transparent;">[dom0]$ </span></span>cp /var/lib/qubes/vm-kernels/2.6.38.3/* /var/lib/qubes/appvms/wififun/kernels/</span></span></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;"><span style="font-weight: normal;"><span style="background: none repeat scroll 0% 0% transparent;">[dom0]$ </span></span>qvm-prefs wififun -s kernelopts "swiotlb=force"</span></span></div><div style="font-style: normal; margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">And then, in the VM:</div><div style="font-style: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><span style="font-family: DejaVu Sans Mono,monospace;"><span style="font-size: x-small;">[wififun]$ sudo yum install kernel-devel-2.6.38.3-10.xenlinux.qubes</span></span></div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">And rebuild the compat-wireless, unload, install modules, and then load drivers again.</div><div style="font-style: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; margin-bottom: 0in;"><b>Summary</b></div><div style="font-style: normal; margin-bottom: 0in;"><br /></div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;">As you can see, Qubes Beta 2 now offers a very advanced networking infrastructure that allows more advanced users to create very sophisticated configurations, allowing for pretty good isolation between various domains and networks. Qubes leaves it up to the user (or admin) to figure out what would be the best configuration -- most users would be happy with the default simple setup with just one Net VM and one Firewall VM, while others would go for much more advanced setups.</div><div style="font-style: normal; font-weight: normal; margin-bottom: 0in;"><br /></div><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/-llpRcqX8oBw/ToQpuLMy_HI/AAAAAAAAAJo/3pZ1S-qHupA/s1600/qubes-adv-config.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="291" src="http://2.bp.blogspot.com/-llpRcqX8oBw/ToQpuLMy_HI/AAAAAAAAAJo/3pZ1S-qHupA/s400/qubes-adv-config.png" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">A bit more advanced networking setup. The usbvm has a 3G modem assigned, and it is possible to dynamically switch between the Net VMs without restarting any other VMs.</td></tr></tbody></table><br /></div>