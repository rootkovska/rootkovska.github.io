---
layout: post
title: 'Qubes OS R3 Alpha preview: Odyssey HAL in action!'
date: '2013-06-21T12:15:00.000+02:00'
author: Joanna Rutkowska
tags: 
modified_time: '2013-06-22T10:56:16.820+02:00'
thumbnail: http://3.bp.blogspot.com/--nDYFJy9De8/UcMVFM2mygI/AAAAAAAAALg/EJORWNCQNTI/s72-c/r3a1-konsoles.png
blogger_id: tag:blogger.com,1999:blog-24586388.post-5526599582625415637
blogger_orig_url: http://theinvisiblethings.blogspot.com/2013/06/qubes-os-r3-alpha-preview-odyssey-hal.html
---

<style type="text/css">P { margin-bottom: 0.08in; }A:link {  }</style>  <br /><div style="margin-bottom: 0in;">In a <a href="http://theinvisiblethings.blogspot.com/2013/03/introducing-qubes-odyssey-framework.html">previous post</a>I have outlined a new direction we're aiming with the Qubes project, which is a departure from using a “hardcoded” hypervisor with Qubes (as well as “hardcoded” Linux as Dom0, GUI domain, etc).</div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">Today I'm happy to announce that we've already completed initial porting of the current Qubes OS into this Hypervisor-Abstraction-Layer-based framework. The new version of Qubes, that we call “R3 Alpha” for now, builds fine, installs fine, and even (mostly) works(!), as can be admired on the screenshot below :) It still uses Xen, of course, but this time in a non-hardcoded way, which allows to replace it easily with another hypervisor, as I discuss below.</div><div style="margin-bottom: 0in;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/--nDYFJy9De8/UcMVFM2mygI/AAAAAAAAALg/EJORWNCQNTI/s1600/r3a1-konsoles.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="225" src="http://3.bp.blogspot.com/--nDYFJy9De8/UcMVFM2mygI/AAAAAAAAALg/EJORWNCQNTI/s400/r3a1-konsoles.png" width="400" /></a></div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;"><style type="text/css">P { margin-bottom: 0.08in; }A:link {  }</style>  </div><div style="margin-bottom: 0in;">Our Qubes Odyssey <i>backend</i><span style="font-style: normal;"></span><span style="font-style: normal;">needed </span>to support a specific hypervisor comprises essentially three parts:</div><ol><li><div style="margin-bottom: 0in;"><b>A libvirt driver</b> to support  a given VMM. In our case we got it (almost) for free, because Xen  4.2 is well supported by libvirt. I wrote “almost” for free,  because some patches to libvirt were still needed, mostly to get rid  of some unjustified simplifying assumptions, such as that all the  backends are always in Dom0, which is not the case for Qubes OS, of  course. Some of those patches were accepted into upstream libvirt,  some (still) not, so we had to fork libvirt.</div></li><li><div style="margin-bottom: 0in;">A VMM-specific <b>implementation  of our vchan</b> – a simple, socket-like, VMM shared memory-based  communication stack between the VMs. Again, in case of Xen 4.2 we  got that (almost) for free, because Xen 4.2 has now included a  libxenvchan component, which is modified (improved and cleaned up)  version of our original vchan (written in early Qubes days for older  Xen versions) contributed and maintained by Daniel De Graff from the  NSA.</div></li><li><div style="margin-bottom: 0in;">Some minor configuration files,  e.g. to tell libvirt which hypervisor protocol to use (in our case:  xen:///), and VM configuration template files.</div></li></ol><div style="margin-bottom: 0in;">Now, if one wanted to switch Xen for some other hypervisor, such as e.g. the KVM, we would need to write a KVM Odyssey backend in a form of providing the above mentioned three elements. Again, libvirt driver we would get for free, configuration files would be trivial to write, and the only task which would require some coding would be the vchan for KVM.</div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;"><style type="text/css">P { margin-bottom: 0.08in; }A:link {  }</style>  </div><div style="margin-bottom: 0in;">Ok, one thing that is left out (non-HAL'ified) for now, is the xc_map_foreign_pages() Xen-specific <a href="http://git.qubes-os.org/?p=joanna/gui-daemon.git;a=blob;f=shmoverride/shmoverride.c;h=0d66e4faa1ed47b4c1ced481df6e1e4819e53fc5;hb=HEAD#l71">function call</a> within our GUI daemon<a href="http://git.qubes-os.org/?p=joanna/gui-daemon.git;a=blob;f=shmoverride/shmoverride.c;h=0d66e4faa1ed47b4c1ced481df6e1e4819e53fc5;hb=HEAD#l71"></a>.</div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">Ideally such call could also be handled by the libvirt API, however it's not clear to us whether true zero-copy page access is really supported (and intended). If it is not, we will try to contribute a patch to libvirt to add such functionality, as it is generally useful for many things that involve high-speed inter-VM communication, of which our GUI virtualization is just one example. So, at this moment, one would need to add an ugly #if (BACKEND_VMM == ...) to the code above and use another VMM's function(s), equivalent to the xc_map_foreign_pages() on Xen.</div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">But besides the above, essentially everything else should Just Work (TM). And that's pretty amazing, I think :) While I personally can't immediately see any security benefit of switching from Xen to KVM, it might appeal to some people for other reasons (Performance? Better hardware support?). The point is: this should be now easy to do.</div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">If one wanted to support some Windows-based hypervisor, on the other hand, such as MS Hyper-V, or Virtual Box on top of Windows, then two more things will need to be taken care of:</div><div style="margin-bottom: 0in;"><br /></div><ol><li><div style="margin-bottom: 0in;">Our core management stack (the  core-admin repository), the core RPC services (mostly the qrexec  daemon, currently part of core-admin-linux repo), and the libvirt  code (core-libvirt, a forked original libvirt with some custom  patches I mentioned above), all would need to build and run fine on  Windows. While this is not a big problem for core-admin (it's all  python) and core-libvirt (it is supposed to build and run on Windows  fine), the qrexec daemon would need to be rewritten with Windows OS  in mind. We're currently working on this step, BTW.</div></li><li><div style="margin-bottom: 0in;">The GUI daemon would also need to be ported to run on Windows, instead of on top of X Server. This is  somehow orthogonal to the need to get rid of the hardcoded  xc_map_foreign_pages() function as mentioned above. This step might  be optional, however, if we wanted to use a Linux-based (and so  Xorg-based GUI server) as a GUI domain.</div></li></ol><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">Once the above two pieces are made Windows-ready (note how I wrote Windows-ready, and not specific-VMM-ready), we can then use any Windows-based hypervisor we want (i.e. for which we have libvirt driver, and can write vchan).</div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">This is again pretty amazing, because it means we don't need N*M variations of each component (where N is the number of VMMs, and M the number of host/GUI OSes to support) – but only N+M! This is similar to how modern compilers are designed using a language-specific frontends (C, C++, Pascal, C#, etc), and architecture-specific backends (x86, x64, ARM, etc), and an Intermediate Language for internal “grinding”, again achieving this N+M number of needed variants instead of N*M, which otherwise would be just totally impractical.</div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">One other detail I would like to point out, and which is also visible on the screenshot above, is that we also got rid of using the Xen-specific Xenstore infrastructure (a registry-like tree-based infrastructure for inter-VM configuration and status exchange), and we replaced it with our own, vchan-based Qubes DB (core-qubesdb).</div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">One interesting thing about Qubes DB is that it get rids of the (overly complex and unnecessary) permission system that is used by xenstore, and instead uses the most simple approach: each VM has its separate Qubes DB daemon, and so a totally separate configuration/state namespace. This is inline with the rest of the Qubes philosophy, which basically says that: <b>permissions is dead, long live separation!</b></div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;"><span style="font-weight: normal;">So, in Qubes OS we just isolate everything by default, unless a user/configuration specifically allows an exception – e.g. no file copy operation between domains is possible, unless the user expresses an explicit consent for it.</span></div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;"><span style="font-weight: normal;">Many old-school security people can't imagine a system without permissions, but </span><span style="font-weight: normal;">if we</span><span style="font-weight: normal;">think about it more, we might get to a conclusion that: 1) permissions are complex and so </span><span style="font-weight: normal;">often </span><span style="font-weight: normal;">difficult to un</span><span style="font-weight: normal;">d</span><span style="font-weight: normal;">erstand and set correctly, 2) require often complex code to parse </span><span style="font-weight: normal;">and </span><span style="font-weight: normal;">make security decisions, and 3) often are absolutely unneeded.</span></div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;"><span style="font-weight: normal;">As a practical example of how permissions </span><span style="font-weight: normal;">schemes </span><span style="font-weight: normal;">might </span><span style="font-weight: normal;">sometime </span><span style="font-weight: normal;">trick even (otherwise somehow smart) developers</span><span style="font-weight: normal;">into making a mistake consider <a href="http://git.qubes-os.org/?p=joanna/core-admin.git;a=commitdiff;h=59f71f634af596c8fe2ef507509bf1ae850286c7">this bug</a> in Qubes </span><span style="font-weight: normal;"></span><span style="font-weight: normal;">we made a </span><span style="font-weight: normal;">long time ago when setting permissions on some xenstore key, which resulted in some information leak (not much of a security problem in general, but still). And just today</span><span style="font-weight: normal;">, Xen.org has published <a href="http://lists.xenproject.org/archives/html/xen-devel/2013-06/msg02123.html">this advisory</a><span style="background-color: yellow;"></span>, that sounds pretty serious, again caused by bad permissions on some xenstore keys. (Yes, we do have <a href="https://groups.google.com/forum/#!msg/qubes-devel/KqZdbcgkTGU/YaTwNcQhcrgJ">updated Xen packages</a> </span><span style="font-weight: normal;"><span style="background-color: yellow;"></span></span><span style="font-weight: normal;">to fix that, of course</span><span style="font-weight: normal;">)</span><span style="font-weight: normal;">.</span></div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">Back to Qubes R3 Alpha, the first successful Qubes based on Odyssey HAL framework. As previously mentioned, we plan to make most of the framework open sourced, specifically all the non-Windows code. However, we're not publishing this Odyssey/R3 code at this moment, mainly for two reasons: 1) we don't want people to immediately start building other backends, such as to support KVM, right at this stage, because we still might want/need to modify some interfaces slightly, e.g. for our vchan, and we don't want to tide our hands now, and 2) the other reason is that we're still in the middle of “Beta” releases for Qubes R2, and we want people to rather focus on testing that, rather stable release, than jumping onto Qubes R3 alpha.</div><div style="margin-bottom: 0in;"><br /></div><div style="margin-bottom: 0in;">In other news: everybody seems to be genuinely surprised that <i>unencrypted</i> information can be <a href="http://en.wikipedia.org/wiki/PRISM_%28surveillance_program%29">intercepted and analyzed</a> without user consent... Can it be that people will "discover" cryptography now? How many of you use PGP everyday? And how long will it take then to understand that cryptography without secure client devices is useless?</div>